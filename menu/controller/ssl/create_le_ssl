#!/bin/bash

######################################################################
#           Auto Install & Optimize LEMP Stack on CentOS            #
#                                                                    #
#                Author: HOSTVN Technical Team                       #
#                  Website: https://hostvn.vn                        #
#                                                                    #
#              Please do not remove copyright. Thank!                #
#  Please do not copy under any circumstance for commercial reason!  #
######################################################################

source /var/hostvn/menu/validate/rule
source /var/hostvn/menu/helpers/function
source /var/hostvn/menu/helpers/variable_common
source /var/hostvn/menu/helpers/menu

printf "%s========================%s\n" "${GREEN}" "${NC}"
printf "%s Cau hinh Let's Encrypt %s\n" "${GREEN}" "${NC}"
printf "%s========================%s\n" "${GREEN}" "${NC}"
echo

_debug_ssl_setup() {
    printf "%s\n" "${YELLOW}Debug thong tin SSL setup:${NC}"
    printf "%s\n" "Domain: ${domain}"
    printf "%s\n" "SSL Type: ${ssl_type} (1=Let's Encrypt, 2=Zero SSL)"
    printf "%s\n" "Domain Type: ${domain_type} (1=Main domain with www, 2=Subdomain)"
    printf "%s\n" "Method: ${method} (http/cf_api)"
    printf "%s\n" "SSL Dir: ${SSL_DIR}/${domain}"
    printf "%s\n" "Vhost Dir: ${VHOST_DIR}/${domain}.conf"
    echo
}

_show_ssl_debug_info() {
    printf "%s\n" "${YELLOW}=== SSL Debug Information ===${NC}"
    printf "%s\n" "Domain: ${domain}"
    printf "%s\n" "SSL Type: ${ssl_type} (1=Let's Encrypt, 2=ZeroSSL)"
    printf "%s\n" "Domain Type: ${domain_type} (1=Main domain with www, 2=Subdomain)"
    printf "%s\n" "Method: ${method}"
    
    printf "%s\n" "${YELLOW}Acme.sh directories:${NC}"
    if [ -d "/root/.acme.sh/${domain}" ]; then
        printf "%s\n" "  /root/.acme.sh/${domain}/ exists"
        ls -la "/root/.acme.sh/${domain}/" 2>/dev/null || echo "    (empty or no permissions)"
    else
        printf "%s\n" "  /root/.acme.sh/${domain}/ does not exist"
    fi
    
    if [ -d "/root/.acme.sh/${domain}_ecc" ]; then
        printf "%s\n" "  /root/.acme.sh/${domain}_ecc/ exists"
        ls -la "/root/.acme.sh/${domain}_ecc/" 2>/dev/null || echo "    (empty or no permissions)"
    else
        printf "%s\n" "  /root/.acme.sh/${domain}_ecc/ does not exist"
    fi
    
    printf "%s\n" "${YELLOW}SSL installation directory:${NC}"
    if [ -d "${SSL_DIR}/${domain}" ]; then
        printf "%s\n" "  ${SSL_DIR}/${domain}/ exists"
        ls -la "${SSL_DIR}/${domain}/" 2>/dev/null || echo "    (empty or no permissions)"
    else
        printf "%s\n" "  ${SSL_DIR}/${domain}/ does not exist"
    fi
    
    printf "%s\n" "${YELLOW}Recent acme.sh log (last 20 lines):${NC}"
    if [ -f "/root/.acme.sh/acme.sh.log" ]; then
        tail -20 "/root/.acme.sh/acme.sh.log"
    else
        printf "%s\n" "  No acme.sh.log found"
    fi
    printf "%s\n" "${YELLOW}=== End Debug Information ===${NC}"
    echo
}

_check_prerequisites() {
    local error_count=0
    
    # Check if acme.sh is installed
    if [ ! -f "/root/.acme.sh/acme.sh" ]; then
        printf "%s\n" "${RED}Loi: acme.sh chua duoc cai dat.${NC}"
        ((error_count++))
    fi
    
    # Check if domain vhost exists
    if [ ! -f "${VHOST_DIR}/${domain}.conf" ]; then
        printf "%s\n" "${RED}Loi: Khong tim thay file cau hinh domain ${VHOST_DIR}/${domain}.conf${NC}"
        ((error_count++))
    fi
    
    # Check nginx config directory
    if [ ! -d "${NGINX_CONF_DIR}" ]; then
        printf "%s\n" "${RED}Loi: Thu muc cau hinh nginx khong ton tai ${NGINX_CONF_DIR}${NC}"
        ((error_count++))
    fi
    
    # For CloudFlare DNS API method, check if CF credentials exist
    if [[ "${method}" == "cf_api" ]]; then
        if [ ! -f "/root/.acme.sh/account.conf" ]; then
            printf "%s\n" "${RED}Loi: Khong tim thay file cau hinh account.conf${NC}"
            ((error_count++))
        else
            check_cf_config=$(grep -w "CF_Key" "/root/.acme.sh/account.conf")
            if [ -z "${check_cf_config}" ]; then
                printf "%s\n" "${RED}Loi: CloudFlare API chua duoc cau hinh. Vui long cau hinh truoc khi su dung.${NC}"
                ((error_count++))
            fi
        fi
    fi
    
    return $error_count
}

_setup_acme_account() {
    # Check if this is the first time using acme.sh
    if [ ! -f "/root/.acme.sh/account.conf" ]; then
        printf "%s\n" "${YELLOW}Lan dau tien su dung acme.sh, can cau hinh tai khoan...${NC}"
        read -r -p "Nhap email cua ban de dang ky tai khoan [admin@$(hostname)]: " user_email
        if [ -z "${user_email}" ]; then
            user_email="admin@$(hostname)"
        fi
        
        # Try to register account
        if [ "${ssl_type}" == "1" ]; then
            # Let's Encrypt
            /root/.acme.sh/acme.sh --register-account -m "${user_email}" --server letsencrypt
        else
            # ZeroSSL - need to register with email for ZeroSSL
            /root/.acme.sh/acme.sh --register-account -m "${user_email}" --server zerossl
        fi
        
        if [ $? -ne 0 ]; then
            printf "%s\n" "${RED}Loi: Khong the dang ky tai khoan. Vui long kiem tra email va thu lai.${NC}"
            return 1
        fi
    fi
    
    # For ZeroSSL, check if account is properly registered
    if [ "${ssl_type}" == "2" ]; then
        # Check if ZeroSSL account is registered with email
        account_check=$(grep -i "zerossl" /root/.acme.sh/account.conf 2>/dev/null || echo "")
        if [ -z "${account_check}" ]; then
            printf "%s\n" "${YELLOW}Dang ky lai tai khoan ZeroSSL...${NC}"
            read -r -p "Nhap email cua ban de dang ky ZeroSSL [admin@$(hostname)]: " user_email
            if [ -z "${user_email}" ]; then
                user_email="admin@$(hostname)"
            fi
            /root/.acme.sh/acme.sh --register-account -m "${user_email}" --server zerossl
            if [ $? -ne 0 ]; then
                printf "%s\n" "${RED}Loi: Khong the dang ky tai khoan ZeroSSL.${NC}"
                return 1
            fi
        fi
    fi
    
    return 0
}

_select_ssl_type(){
    echo "Lua chon loai SSL mien phi muon su dung"
    PS3="Nhap vao cau tra loi cua ban: "
    options_ssl_type=(
        "Let's Encrypt"
        "Zero SSL"
    )
    select opt_ssl_type in "${options_ssl_type[@]}"; do
        case $opt_ssl_type in
        "Let's Encrypt")
            ssl_type="1"
            break
            ;;
        "Zero SSL")
            ssl_type="2"
            break
            ;;
        *) printf "%s\n" "${RED}Lua chon cua ban khong chinh xac. Vui long chon lai${NC}" ;;
        esac
    done
}

_confirm_sign_ssl() {
    printf "${RED}%s${NC}\n" "Luu y: Let's Encrypt gioi han so request SSL vi vay viec tao qua nhieu request SSL se bi chan ko tao duoc SSL."
    while true; do
        read -r -p "Ban muon cai dat SSL cho Domain ${domain} ? (y/n) " promt_sign_ssl
        echo
        if [[ "${promt_sign_ssl}" =~ ^([yY])$ || "${promt_sign_ssl}" =~ ^([nN])$ ]]; then
            break
        else
            printf "%s\n" "${RED}Gia tri khong chinh xac. Vui long nhap lai.${NC}"
        fi
    done

    if [[ "${promt_sign_ssl}" =~ ^([yY])$ ]]; then
        echo "Ten mien cua ban la ten mien chinh hay sub-domain ?"
        PS3="Nhap vao cau tra loi cua ban: "
        options=(
            "Ten mien chinh (Bao gom dang www.domain.com)"
            "Sub-domain"
        )
        select opt in "${options[@]}"; do
            case $opt in
            "Ten mien chinh (Bao gom dang www.domain.com)")
                domain_type="1"
                break
                ;;
            "Sub-domain")
                domain_type="2"
                break
                ;;
            *) printf "%s\n" "${RED}Lua chon cua ban khong chinh xac. Vui long chon lai${NC}" ;;
            esac
        done

        _select_ssl_type
    fi
}

_method_verify() {
    clear
    printf "%s\n" "Lua chon phuong thuc xac thuc"
    PS3="Nhap vao lua chon cua ban [ 1 - 3 ]: "
    options_method=("HTTP" "CloudFlare DNS API" "Cancel")
    select opt_method in "${options_method[@]}"; do
        case $opt_method in
        "HTTP")
            method="http"
            break
            ;;
        "CloudFlare DNS API")
            method="cf_api"
            break
            ;;
        "Cancel")
            method="cancel"
            break
            ;;
        *) printf "${RED}%s${NC}\n" "Lua chon cua ban khong chinh xac. Vui long chon lai. $REPLY" ;;
        esac
    done
}

_sign_ssl() {
    # Clean up any broken SSL certificates first
    _cleanup_broken_ssl
    
    if [ -d "/root/.acme.sh/${domain}" ]; then
        rm -rf /root/.acme.sh/"${domain}"
    fi
    
    # Clean up any existing ECC certificates
    if [ -d "/root/.acme.sh/${domain}_ecc" ]; then
        rm -rf /root/.acme.sh/"${domain}_ecc"
    fi
    
    /root/.acme.sh/acme.sh --upgrade
    clear

    # Issue certificate
    ssl_command_result=1
    if [[ -n "${method}" && "${method}" == "cf_api" ]]; then
        if [ "${domain_type}" == "2" ]; then
            if [ "${ssl_type}" == "1" ]; then
                /root/.acme.sh/acme.sh --issue --dns dns_cf -d "${domain}" --server letsencrypt --force
                ssl_command_result=$?
            else
                /root/.acme.sh/acme.sh --issue --dns dns_cf -d "${domain}" --server zerossl --force
                ssl_command_result=$?
            fi
        else
            if [ "${ssl_type}" == "1" ]; then
                /root/.acme.sh/acme.sh --issue --dns dns_cf -d "${domain}" -d "www.${domain}" --server letsencrypt --force
                ssl_command_result=$?
            else
                /root/.acme.sh/acme.sh --issue --dns dns_cf -d "${domain}" -d "www.${domain}" --server zerossl --force
                ssl_command_result=$?
            fi
        fi
    elif [[ -n "${method}" && "${method}" == "cancel" ]]; then
        cancel="${RED}Huy thao tac.${NC}"
        return 1
    else
        if [ "${domain_type}" == "2" ]; then
            if [ "${ssl_type}" == "1" ]; then
                /root/.acme.sh/acme.sh --issue --nginx "${VHOST_DIR}"/"${domain}".conf -d "${domain}" --server letsencrypt --force
                ssl_command_result=$?
            else
                /root/.acme.sh/acme.sh --issue --nginx "${VHOST_DIR}"/"${domain}".conf -d "${domain}" --server zerossl --force
                ssl_command_result=$?
            fi
        else
            if [ "${ssl_type}" == "1" ]; then
                /root/.acme.sh/acme.sh --issue --nginx "${VHOST_DIR}"/"${domain}".conf -d "${domain}" -d "www.${domain}" --server letsencrypt --force
                ssl_command_result=$?
            else
                /root/.acme.sh/acme.sh --issue --nginx "${VHOST_DIR}"/"${domain}".conf -d "${domain}" -d "www.${domain}" --server zerossl --force
                ssl_command_result=$?
            fi
        fi
    fi

    # Check if certificate issuance was successful
    if [ $ssl_command_result -ne 0 ]; then
        printf "%s\n" "${RED}Loi: Khong the tao chung chi SSL. Vui long kiem tra log va thu lai.${NC}"
        return 1
    fi

    # Determine correct certificate path - handle both RSA and ECC certificates
    cert_path="/root/.acme.sh/${domain}"
    key_file="${domain}.key"
    cert_file="${domain}.cer"
    
    # Check for ECC certificate first (ZeroSSL sometimes creates ECC)
    if [ -d "/root/.acme.sh/${domain}_ecc" ]; then
        cert_path="/root/.acme.sh/${domain}_ecc"
    fi
    
    # Verify certificate files exist with proper extensions
    if [[ ! -f "${cert_path}/${cert_file}" && ! -f "${cert_path}/fullchain.cer" ]]; then
        printf "%s\n" "${RED}Loi: Khong tim thay file chung chi (.cer hoac fullchain.cer). Qua trinh tao SSL that bai.${NC}"
        printf "%s\n" "${RED}Thu muc tim kiem: ${cert_path}${NC}"
        return 1
    fi
    
    if [[ ! -f "${cert_path}/${key_file}" ]]; then
        printf "%s\n" "${RED}Loi: Khong tim thay file khoa rieng tu (.key). Qua trinh tao SSL that bai.${NC}"
        printf "%s\n" "${RED}Thu muc tim kiem: ${cert_path}${NC}"
        return 1
    fi

    if [ ! -d "${SSL_DIR}/${domain}" ]; then
        mkdir -p "${SSL_DIR}"/"${domain}"
    fi

    # Remove old certificates
    if [ -f "${SSL_DIR}/${domain}/key.pem" ]; then
        rm -rf "${SSL_DIR}"/"${domain}"/key.pem
    fi

    if [ -f "${SSL_DIR}/${domain}/cert.pem" ]; then
        rm -rf "${SSL_DIR}"/"${domain}"/cert.pem
    fi

    # Install certificate with proper error handling
    install_result=1
    
    # Try installing with detected certificate files
    if [ -f "${cert_path}/fullchain.cer" ]; then
        /root/.acme.sh/acme.sh --install-cert -d "${domain}" \
            --key-file "${SSL_DIR}"/"${domain}"/key.pem \
            --fullchain-file "${SSL_DIR}"/"${domain}"/cert.pem \
            --cert-file "${cert_path}/fullchain.cer" \
            --key "${cert_path}/${key_file}"
        install_result=$?
    else
        /root/.acme.sh/acme.sh --install-cert -d "${domain}" \
            --key-file "${SSL_DIR}"/"${domain}"/key.pem \
            --fullchain-file "${SSL_DIR}"/"${domain}"/cert.pem \
            --cert-file "${cert_path}/${cert_file}" \
            --key "${cert_path}/${key_file}"
        install_result=$?
    fi
    
    if [ $install_result -ne 0 ]; then
        printf "%s\n" "${RED}Loi: Khong the cai dat chung chi SSL tu acme.sh.${NC}"
        printf "%s\n" "${YELLOW}Thu cach khac: Copy truc tiep file chung chi...${NC}"
        
        # Fallback: copy files directly
        if [ -f "${cert_path}/${key_file}" ]; then
            cp "${cert_path}/${key_file}" "${SSL_DIR}/${domain}/key.pem"
            chmod 600 "${SSL_DIR}/${domain}/key.pem"
        fi
        
        if [ -f "${cert_path}/fullchain.cer" ]; then
            cp "${cert_path}/fullchain.cer" "${SSL_DIR}/${domain}/cert.pem"
        elif [ -f "${cert_path}/${cert_file}" ]; then
            cp "${cert_path}/${cert_file}" "${SSL_DIR}/${domain}/cert.pem"
        fi
        
        # Verify files were copied successfully
        if [[ ! -f "${SSL_DIR}/${domain}/key.pem" || ! -f "${SSL_DIR}/${domain}/cert.pem" ]]; then
            printf "%s\n" "${RED}Loi: Khong the copy chung chi SSL.${NC}"
            return 1
        fi
        
        printf "%s\n" "${GREEN}Copy chung chi thanh cong.${NC}"
    fi

    return 0
}

_edit_vhost() {
    # Tạo thư mục extra nếu chưa có
    if [ ! -d "${NGINX_CONF_DIR}/extra" ]; then
        mkdir -p "${NGINX_CONF_DIR}/extra"
    fi

    # Tạo file ssl.conf nếu chưa có
    if [ ! -f "${NGINX_CONF_DIR}/extra/ssl.conf" ]; then
        cat > "${NGINX_CONF_DIR}/extra/ssl.conf" << EOF
# SSL
ssl_session_timeout  1d;
ssl_session_cache    shared:SSL:80m;
ssl_session_tickets  off;

# Diffie-Hellman parameter for DHE ciphersuites
ssl_dhparam /etc/nginx/ssl/dhparams.pem;

# Mozilla Intermediate configuration
ssl_protocols        TLSv1.2 TLSv1.3;
ssl_ciphers          ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;

# OCSP Stapling
#ssl_stapling         on;
#ssl_stapling_verify  on;
resolver             1.1.1.1 1.0.0.1 8.8.8.8 8.8.4.4 208.67.222.222 208.67.220.220 valid=10m;
resolver_timeout     10s;
EOF
    fi

    # Đảm bảo có dhparams.pem
    if [ ! -d "${NGINX_CONF_DIR}/ssl" ]; then
        mkdir -p "${NGINX_CONF_DIR}/ssl"
    fi
    
    if [ ! -f "${NGINX_CONF_DIR}/ssl/dhparams.pem" ]; then
        # Sử dụng dhparams.pem đã có sẵn hoặc tạo mới
        if [ -f "/etc/ssl/dhparams.pem" ]; then
            cp /etc/ssl/dhparams.pem "${NGINX_CONF_DIR}/ssl/dhparams.pem"
        else
            printf "%s\n" "${YELLOW}Tạo file dhparams.pem cho SSL (có thể mất 1-2 phút)...${NC}"
            openssl dhparam -out "${NGINX_CONF_DIR}/ssl/dhparams.pem" 2048 >/dev/null 2>&1
        fi
    fi

    # Tạo file chuyển hướng HTTP sang HTTPS 
    if [ ! -f "${NGINX_CONF_DIR}/extra/https.conf" ]; then
        cat > "${NGINX_CONF_DIR}/extra/https.conf" << EOF
# Auto-generated HTTPS redirect config
if (\$http_x_forwarded_proto != 'https') {
    return 301 https://\$host\$request_uri;
}
EOF
    fi

    # Lưu lại file vhost cũ
    cp "${VHOST_DIR}/${domain}.conf" "${VHOST_DIR}/${domain}.conf.bak_$(date +%Y%m%d%H%M%S)"
    
    # Trích xuất thông tin server_name để xác định đúng block server của domain
    DOMAIN_SERVER_NAME=$(grep -w "server_name" "${VHOST_DIR}/${domain}.conf" | grep -w "${domain}" | head -1 | awk '{$1=""; print $0}' | sed 's/^ *//g' | sed 's/;//')
    
    # Lấy phần upstream (nếu có) và lưu lại
    UPSTREAM_CONTENT=$(awk '/^upstream/{flag=1; print; next} /^server/{flag=0} flag' "${VHOST_DIR}/${domain}.conf")
    
    # Tạo file vhost tạm thời
    TMP_VHOST="${VHOST_DIR}/${domain}.conf.tmp"
    
    # Ghi upstream vào file tạm (nếu có)
    if [ -n "$UPSTREAM_CONTENT" ]; then
        echo "$UPSTREAM_CONTENT" > "$TMP_VHOST"
        echo "" >> "$TMP_VHOST"
    else
        # Tạo file rỗng nếu không có upstream
        > "$TMP_VHOST"
    fi
    
    # Thêm block 80 redirect
    cat >> "$TMP_VHOST" << EOF
server {
    listen 80;
    server_name ${DOMAIN_SERVER_NAME};
    
    # Chuyển hướng tất cả HTTP traffic sang HTTPS
    include ${NGINX_CONF_DIR}/extra/https.conf;
    
    # Các file cấu hình Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /usr/share/nginx/html;
    }
}

EOF
    
    # Xử lý từng server block trong file cấu hình
    # Dùng AWK để xử lý các block server một cách chính xác
    awk -v domain="${domain}" -v ssl_dir="${SSL_DIR}" -v nginx_conf_dir="${NGINX_CONF_DIR}" '
    # Lưu trạng thái
    BEGIN {
        in_server = 0;
        target_server = 0;
        server_content = "";
        inside_braces = 0;
    }
    
    # Xác định bắt đầu server block
    /^[[:space:]]*server[[:space:]]*\{/ {
        in_server = 1;
        inside_braces = 1;
        server_content = $0 "\n";
        next;
    }
    
    # Nếu đang ở trong server block, kiểm tra xem có phải server_name chứa domain cần xử lý không
    in_server && /[[:space:]]*server_name/ && $0 ~ domain {
        target_server = 1;
    }
    
    # Theo dõi các dấu ngoặc để biết khi nào kết thúc server block
    in_server && /\{/ {
        inside_braces++;
    }
    
    in_server && /\}/ {
        inside_braces--;
        if (inside_braces == 0) {
            # Kết thúc server block
            server_content = server_content $0 "\n";
            
            # Nếu đây là server block chứa domain cần xử lý
            if (target_server && server_content ~ /listen[[:space:]]*80;/) {
                # Chuyển port 80 thành 443 ssl http2
                gsub(/listen[[:space:]]*80;/, "listen 443 ssl http2;", server_content);
                
                # Thêm cấu hình SSL sau error_log hoặc vào cuối block nếu không có error_log
                if (server_content ~ /error_log/) {
                    gsub(/error_log[^\n]*\n/, "&\n    # SSL configuration\n    include " nginx_conf_dir "/extra/ssl.conf;\n    ssl_certificate " ssl_dir "/" domain "/cert.pem;\n    ssl_certificate_key " ssl_dir "/" domain "/key.pem;\n", server_content);
                } else {
                    # Thêm cấu hình SSL trước dấu "}" cuối cùng của server block
                    gsub(/}[[:space:]]*$/, "    # SSL configuration\n    include " nginx_conf_dir "/extra/ssl.conf;\n    ssl_certificate " ssl_dir "/" domain "/cert.pem;\n    ssl_certificate_key " ssl_dir "/" domain "/key.pem;\n}", server_content);
                }
            }
            
            # Nếu không phải server block cần xử lý hoặc đã là HTTPS, giữ nguyên
            printf "%s", server_content;
            
            # Reset các biến
            in_server = 0;
            target_server = 0;
            server_content = "";
            next;
        }
    }
    
    # Thu thập nội dung của server block
    in_server {
        server_content = server_content $0 "\n";
        next;
    }
    
    # Bỏ qua các block server và in các dòng khác
    !in_server {
        print;
    }
    ' "${VHOST_DIR}/${domain}.conf" >> "$TMP_VHOST"
    
    # Thay thế file vhost cũ
    mv "$TMP_VHOST" "${VHOST_DIR}/${domain}.conf"

    # Kiểm tra cú pháp cấu hình nginx sau khi chỉnh sửa
    printf "%s\n" "${GREEN}Kiểm tra cú pháp cấu hình Nginx sau khi chỉnh sửa...${NC}"
    if nginx -t > /dev/null 2>&1; then
        printf "%s\n" "${GREEN}Cấu hình Nginx hợp lệ. Đang reload Nginx...${NC}"
        systemctl reload nginx
    else
        printf "%s\n" "${RED}Có lỗi trong cấu hình Nginx. Chi tiết lỗi:${NC}"
        nginx -t
        printf "%s\n" "${YELLOW}Đang khôi phục file cấu hình gốc...${NC}"
        cp "${VHOST_DIR}/${domain}.conf.bak_$(date +%Y%m%d%H%M%S)" "${VHOST_DIR}/${domain}.conf"
        printf "%s\n" "${RED}Cấu hình SSL không thành công. Vui lòng kiểm tra lại cấu hình Nginx.${NC}"
        return 1
    fi
}

_run() {
    _confirm_sign_ssl
    if [[ "${promt_sign_ssl}" =~ ^([yY])$ ]]; then
        _check_prerequisites
        if [ $? -ne 0 ]; then
            printf "%s\n" "${RED}Khong the tiep tuc do loi cau hinh. Vui long sua cac loi tren truoc.${NC}"
            return 1
        fi

        # Setup acme.sh account if needed
        _setup_acme_account
        if [ $? -ne 0 ]; then
            printf "%s\n" "${RED}Khong the cau hinh tai khoan SSL. Huy thao tac.${NC}"
            return 1
        fi

        check_nginx_status

        if [ -z "${ALERT}" ]; then
            if [ -f "/root/.acme.sh/account.conf" ]; then
                check_cf_config=$(grep -w "CF_Key" "/root/.acme.sh/account.conf")
                if [ -n "${check_cf_config}" ]; then
                    _method_verify
                fi
            fi

            if [ "${method}" == "http" ]; then
                check_a_record "${domain}"
            fi
        fi

        if [ -z "${ALERT}" ]; then
            # Show debug information
            _debug_ssl_setup
            
            # Fix ZeroSSL account issues if needed
            _fix_zerossl_account
            if [ $? -ne 0 ]; then
                printf "%s\n" "${RED}Khong the sua loi tai khoan ZeroSSL. Vui long thu lai.${NC}"
                return 1
            fi
            
            _sign_ssl
            ssl_result=$?

            if [ -n "${cancel}" ]; then
                clear
                printf "%s\n" "${cancel}"
            elif [ $ssl_result -eq 0 ]; then
                # Verify SSL files were created successfully
                if [[ -f "${SSL_DIR}/${domain}/key.pem" && -f "${SSL_DIR}/${domain}/cert.pem" && -s "${SSL_DIR}/${domain}/key.pem" && -s "${SSL_DIR}/${domain}/cert.pem" ]]; then
                    _edit_vhost
                    sleep 2
                    if nginx -t; then
                        # Tự động tạo file cấu hình SSL đầy đủ cho nginx
                        if [ ! -d "${NGINX_CONF_DIR}/extra" ]; then
                            mkdir -p "${NGINX_CONF_DIR}/extra"
                        fi
                        cat > "${NGINX_CONF_DIR}/extra/https.conf" <<EOF
# Auto-generated SSL config for nginx
ssl_protocols TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers on;
ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305';
ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;
ssl_session_tickets off;
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
ssl_stapling on;
ssl_stapling_verify on;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;
# ssl_trusted_certificate ${SSL_DIR}/${domain}/cert.pem;
EOF

                        # Kiểm tra và chèn block server HTTPS vào vhost nếu chưa có
                        if ! grep -q 'listen 443' "${VHOST_DIR}/${domain}.conf"; then
                            cat <<EOB >> "${VHOST_DIR}/${domain}.conf"

server {
    listen 443 ssl http2;
    server_name ${domain} www.${domain};
    root /home/${domain}/public_html;
    index index.php index.html index.htm;
    access_log /var/log/nginx/${domain}_ssl.access.log;
    error_log /var/log/nginx/${domain}_ssl.error.log;
    include ${NGINX_CONF_DIR}/extra/https.conf;
    ssl_certificate ${SSL_DIR}/${domain}/cert.pem;
    ssl_certificate_key ${SSL_DIR}/${domain}/key.pem;
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass unix:/run/php-fpm/www.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
    # Các cấu hình bổ sung khác nếu cần
}
EOB
                        fi

                        # Xóa include https.conf khỏi block listen 80 nếu có
                        sed -i '/include .*https.conf/d' "${VHOST_DIR}/${domain}.conf"

                        sleep 2
                        if nginx -t; then
                            restart_service
                            clear
                            echo
                            printf "%s\n" "${GREEN}Cau hinh SSL thanh cong.${NC}"
                            printf "%s\n" "${GREEN}Domain: ${domain}${NC}"
                            printf "%s\n" "${GREEN}SSL files: ${SSL_DIR}/${domain}/cert.pem${NC}"
                            echo
                        else
                            clear
                            nginx -t
                            printf "%s\n" "${RED}Loi cau hinh vhost. Vui long kiem tra cau hinh nginx.${NC}"
                            printf "%s\n" "${RED}Ban co the su dung chuc nang rewrite config de sua chua.${NC}"
                            echo
                        fi
                    else
                        clear
                        nginx -t
                        printf "%s\n" "${RED}Loi cau hinh vhost. Vui long kiem tra cau hinh nginx.${NC}"
                        printf "%s\n" "${RED}Ban co the su dung chuc nang rewrite config de sua chua.${NC}"
                        echo
                    fi
                else
                    echo
                    printf "%s\n" "${RED}Cau hinh SSL that bai. File chung chi khong ton tai hoac bi loi.${NC}"
                    printf "%s\n" "${RED}Vui long kiem tra log acme.sh: /root/.acme.sh/acme.sh.log${NC}"
                    echo
                fi
            else
                echo
                printf "%s\n" "${RED}Cau hinh SSL that bai.${NC}"
                printf "%s\n" "${RED}Vui long kiem tra cau hinh domain va DNS records.${NC}"
                printf "%s\n" "${RED}Log chi tiet: /root/.acme.sh/acme.sh.log${NC}"
                echo
                printf "%s\n" "${YELLOW}Hien thi thong tin debug:${NC}"
                _show_ssl_debug_info
            fi
        else
            clear
            echo
            printf "%s\n" "${ALERT}"
            echo
        fi
    else
        clear
        echo
        printf "%s\n" "${RED}Ban da chon huy thao tac.${NC}"
        echo
    fi
}

_cleanup_broken_ssl() {
    # Clean up broken SSL certificate directories
    printf "%s\n" "${YELLOW}Kiem tra va don dep chung chi SSL bi loi...${NC}"
    
    # Check for broken certificate directories
    broken_dirs=()
    if [ -d "/root/.acme.sh/${domain}" ]; then
        if [[ ! -f "/root/.acme.sh/${domain}/${domain}.key" || ! -f "/root/.acme.sh/${domain}/${domain}.cer" ]]; then
            broken_dirs+=("/root/.acme.sh/${domain}")
        fi
    fi
    
    if [ -d "/root/.acme.sh/${domain}_ecc" ]; then
        if [[ ! -f "/root/.acme.sh/${domain}_ecc/${domain}.key" || ! -f "/root/.acme.sh/${domain}_ecc/${domain}.cer" ]]; then
            broken_dirs+=("/root/.acme.sh/${domain}_ecc")
        fi
    fi
    
    # Remove broken directories
    for broken_dir in "${broken_dirs[@]}"; do
        if [ -d "${broken_dir}" ]; then
            printf "%s\n" "${YELLOW}Xoa thu muc chung chi bi loi: ${broken_dir}${NC}"
            rm -rf "${broken_dir}"
        fi
    done
    
    # Also clean up any existing SSL files in nginx directory that might be corrupted
    if [ -d "${SSL_DIR}/${domain}" ]; then
        if [[ ! -s "${SSL_DIR}/${domain}/key.pem" || ! -s "${SSL_DIR}/${domain}/cert.pem" ]]; then
            printf "%s\n" "${YELLOW}Xoa chung chi nginx bi loi: ${SSL_DIR}/${domain}${NC}"
            rm -rf "${SSL_DIR}/${domain}"
        fi
    fi
}

_fix_zerossl_account() {
    # Fix ZeroSSL account registration issue
    if [ "${ssl_type}" == "2" ]; then
        printf "%s\n" "${YELLOW}Kiem tra va sua loi tai khoan ZeroSSL...${NC}"
        
        # Check if ZeroSSL account needs registration
        zerossl_error=$(grep -i "No EAB credentials found for ZeroSSL" /root/.acme.sh/acme.sh.log 2>/dev/null || echo "")
        if [ -n "${zerossl_error}" ] || [ ! -f "/root/.acme.sh/account.conf" ]; then
            printf "%s\n" "${YELLOW}Can dang ky tai khoan ZeroSSL voi email...${NC}"
            read -r -p "Nhap email hop le de dang ky ZeroSSL: " zerossl_email
            if [ -z "${zerossl_email}" ]; then
                # random text
                printf "%s\n" "${YELLOW}Khong nhap email, su dung email mac dinh...${NC}"
                zerossl_email="$(openssl rand -hex 8)@tinycp.me"
            fi
            
            # Register account with ZeroSSL
            /root/.acme.sh/acme.sh --register-account -m "${zerossl_email}" --server zerossl
            if [ $? -eq 0 ]; then
                printf "%s\n" "${GREEN}Dang ky tai khoan ZeroSSL thanh cong.${NC}"
                return 0
            else
                printf "%s\n" "${RED}Loi dang ky tai khoan ZeroSSL.${NC}"
                return 1
            fi
        fi
    fi
    return 0
}

ALERT=""
domain=""
method=""
cancel=""
check_ssl_config=""

select_domain
if [[ -z "${domain}" && -z "${ALERT}" ]]; then
    clear
    echo
    printf "%s\n" "${RED}Ban da chon huy thao tac.${NC}"
    echo
else
    if [ -z "${ALERT}" ]; then
        check_ssl_config=$(grep -w "https.conf" "${VHOST_DIR}"/"${domain}".conf)
        if [ -n "${check_ssl_config}" ]; then
            clear
            printf "%s\n" "${RED}Ten mien da duoc cau hinh SSL. Vui long xoa cau hinh SSL cu truoc.${NC}"
        else
            _run
        fi
    else
        clear
        echo
        printf "%s\n" "${ALERT}"
        echo
    fi
fi

menu_ssl
